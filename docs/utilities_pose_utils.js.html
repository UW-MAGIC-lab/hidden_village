<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utilities/pose_utils.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utilities/pose_utils.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { POSE_LANDMARKS } from "@mediapipe/holistic/holistic";

/**
 ****************************************************************************
 * The following section contains landmark groupings useful for the project *
 ****************************************************************************
 **/

POSE_LANDMARKS.PELVIS = 34;
POSE_LANDMARKS.SOLAR_PLEXIS = 33;
const HAND_LANDMARKS = {
  WRIST: 0,
  THUMB_CMC: 1,
  THUMB_MCP: 2,
  THUMB_IP: 3,
  THUMB_TIP: 4,
  INDEX_FINGER_MCP: 5,
  INDEX_FINGER_PIP: 6,
  INDEX_FINGER_DIP: 7,
  INDEX_FINGER_TIP: 8,
  MIDDLE_FINGER_MCP: 9,
  MIDDLE_FINGER_PIP: 10,
  MIDDLE_FINGER_DIP: 11,
  MIDDLE_FINGER_TIP: 12,
  RING_FINGER_MCP: 13,
  RING_FINGER_PIP: 14,
  RING_FINGER_DIP: 15,
  RING_FINGER_TIP: 16,
  PINKY_MCP: 17,
  PINKY_PIP: 18,
  PINKY_DIP: 19,
  PINKY_TIP: 20,
};

const LANDMARK_GROUPINGS = {
  BICEP_LANDMARKS: (({
    RIGHT_SHOULDER,
    LEFT_SHOULDER,
    RIGHT_ELBOW,
    LEFT_ELBOW,
  }) => ({
    RIGHT_SHOULDER,
    LEFT_SHOULDER,
    RIGHT_ELBOW,
    LEFT_ELBOW,
  }))(POSE_LANDMARKS),
  FOREARM_LANDMARKS: (({
    RIGHT_ELBOW,
    RIGHT_WRIST,
    LEFT_ELBOW,
    LEFT_WRIST,
  }) => ({
    RIGHT_ELBOW,
    RIGHT_WRIST,
    LEFT_ELBOW,
    LEFT_WRIST,
  }))(POSE_LANDMARKS),
  THIGH_LANDMARKS: (({
    LEFT_HIP,
    RIGHT_HIP,
    LEFT_KNEE,
    RIGHT_KNEE,
    PELVIS,
  }) => ({
    LEFT_HIP,
    RIGHT_HIP,
    LEFT_KNEE,
    RIGHT_KNEE,
    PELVIS,
  }))(POSE_LANDMARKS),
  TORSO_LANDMARKS: (({ RIGHT_SHOULDER, LEFT_SHOULDER, SOLAR_PLEXIS }) => ({
    RIGHT_SHOULDER,
    LEFT_SHOULDER,
    SOLAR_PLEXIS,
  }))(POSE_LANDMARKS),
  SHIN_LANDMARKS: (({ LEFT_KNEE, RIGHT_KNEE, LEFT_ANKLE, RIGHT_ANKLE }) => ({
    LEFT_KNEE,
    RIGHT_KNEE,
    LEFT_ANKLE,
    RIGHT_ANKLE,
  }))(POSE_LANDMARKS),
  ABDOMEN_LANDMARKS: (({ PELVIS, LEFT_HIP }) => ({ PELVIS, LEFT_HIP }))(
    POSE_LANDMARKS
  ),
  WRIST_LANDMARK: (({ WRIST }) => ({ WRIST }))(HAND_LANDMARKS),
  PALM_LANDMARKS: (({
    WRIST,
    THUMB_CMC,
    INDEX_FINGER_MCP,
    MIDDLE_FINGER_MCP,
    RING_FINGER_MCP,
    PINKY_MCP,
  }) => ({
    WRIST,
    THUMB_CMC,
    INDEX_FINGER_MCP,
    MIDDLE_FINGER_MCP,
    RING_FINGER_MCP,
    PINKY_MCP,
  }))(HAND_LANDMARKS),
  THUMB_LANDMARKS: (({ THUMB_CMC, THUMB_MCP, THUMB_IP, THUMB_TIP }) => ({
    THUMB_CMC,
    THUMB_MCP,
    THUMB_IP,
    THUMB_TIP,
  }))(HAND_LANDMARKS),
  INDEX_FINGER_LANDMARKS: (({
    INDEX_FINGER_MCP,
    INDEX_FINGER_PIP,
    INDEX_FINGER_DIP,
    INDEX_FINGER_TIP,
  }) => ({
    INDEX_FINGER_MCP,
    INDEX_FINGER_PIP,
    INDEX_FINGER_DIP,
    INDEX_FINGER_TIP,
  }))(HAND_LANDMARKS),
  MIDDLE_FINGER_LANDMARKS: (({
    MIDDLE_FINGER_MCP,
    MIDDLE_FINGER_PIP,
    MIDDLE_FINGER_DIP,
    MIDDLE_FINGER_TIP,
  }) => ({
    MIDDLE_FINGER_MCP,
    MIDDLE_FINGER_PIP,
    MIDDLE_FINGER_DIP,
    MIDDLE_FINGER_TIP,
  }))(HAND_LANDMARKS),
  RING_FINGER_LANDMARKS: (({
    RING_FINGER_MCP,
    RING_FINGER_PIP,
    RING_FINGER_DIP,
    RING_FINGER_TIP,
  }) => ({
    RING_FINGER_MCP,
    RING_FINGER_PIP,
    RING_FINGER_DIP,
    RING_FINGER_TIP,
  }))(HAND_LANDMARKS),
  PINKY_LANDMARKS: (({ PINKY_MCP, PINKY_PIP, PINKY_DIP, PINKY_TIP }) => ({
    PINKY_MCP,
    PINKY_PIP,
    PINKY_DIP,
    PINKY_TIP,
  }))(HAND_LANDMARKS),
};

// create an object that represents the three points necessary to calculate a body
// segment's angle
const SEGMENT_ANGLE_LANDMARKS = {
  RIGHT_BICEP: (({ RIGHT_HIP, RIGHT_SHOULDER, RIGHT_ELBOW }) => ({
    RIGHT_HIP,
    RIGHT_SHOULDER,
    RIGHT_ELBOW,
  }))(POSE_LANDMARKS),
  RIGHT_FOREARM: (({ RIGHT_SHOULDER, RIGHT_ELBOW, RIGHT_WRIST }) => ({
    RIGHT_SHOULDER,
    RIGHT_ELBOW,
    RIGHT_WRIST,
  }))(POSE_LANDMARKS),
  LEFT_BICEP: (({ LEFT_HIP, LEFT_SHOULDER, LEFT_ELBOW }) => ({
    LEFT_HIP,
    LEFT_SHOULDER,
    LEFT_ELBOW,
  }))(POSE_LANDMARKS),
  LEFT_FOREARM: (({ LEFT_SHOULDER, LEFT_ELBOW, LEFT_WRIST }) => ({
    LEFT_SHOULDER,
    LEFT_ELBOW,
    LEFT_WRIST,
  }))(POSE_LANDMARKS),
};

export { LANDMARK_GROUPINGS, SEGMENT_ANGLE_LANDMARKS };

/**
 *******************************************************************************
 * The following section contains utility functions for manipulating pose data *
 *******************************************************************************
 **/

const landmarkCoordinates = (landmark) => {
  if (landmark) {
    return [landmark.x, landmark.y];
  }
};

const preprocessPoseData = (poseData) => {
  let lhLandmarks, rhLandmarks, poseLandmarks;
  if (poseData.leftHandLandmarks) {
    lhLandmarks = Object.values(poseData.leftHandLandmarks).map(
      landmarkCoordinates
    );
  } else {
    lhLandmarks = new Array(42).fill(-1); // x,y coordinates for 21 hand landmarks
  }
  if (poseData.rightHandLandmarks) {
    rhLandmarks = Object.values(poseData.rightHandLandmarks).map(
      landmarkCoordinates
    );
  } else {
    rhLandmarks = new Array(42).fill(-1); // x,y coordinates for 21 hand landmarks
  }
  if (poseData.poseLandmarks) {
    poseLandmarks = Object.values(poseData.poseLandmarks).map(
      landmarkCoordinates
    );
  } else {
    poseLandmarks = new Array(66).fill(-1); // x,y coordinates for 33 pose landmarks
  }
  return [poseLandmarks, lhLandmarks, rhLandmarks].flat(4);
};

const landmarkToCoordinates = (data, width, height) => {
  return (landmark) => {
    const coordinates = Object.assign({}, data[landmark]);
    // scale the coordinates from 0 to 1 to a size within the column's width and height
    coordinates.x *= width;
    coordinates.y *= height;
    // // bound the coordinates based on height and width of the newly scaled coordinates
    // coordinates.x = Math.min(Math.max(coordinates.x, 0), width);
    // coordinates.y = Math.min(Math.max(coordinates.y, 0), height);
    return coordinates;
  };
};

const objMap = (obj, func) => {
  return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, func(v)]));
};

/**
 * @param {Object} newResults - an object containing the new pose detection results
 * @returns {Object} - an object containing the pose detection results with calculated
 * results for pevlis and solar plexis
 */
const enrichLandmarks = (newResults) => {
  const abdomenLandmarks = (({ RIGHT_HIP, LEFT_HIP, RIGHT_SHOULDER }) => ({
    RIGHT_HIP,
    LEFT_HIP,
    RIGHT_SHOULDER,
  }))(POSE_LANDMARKS);
  let solarPlexis = {};
  let pelvis = {};
  if (newResults.poseLandmarks) {
    pelvis.x =
      (newResults.poseLandmarks[abdomenLandmarks.RIGHT_HIP].x +
        newResults.poseLandmarks[abdomenLandmarks.LEFT_HIP].x) /
      2;
    pelvis.y =
      (newResults.poseLandmarks[abdomenLandmarks.RIGHT_HIP].y +
        newResults.poseLandmarks[abdomenLandmarks.LEFT_HIP].y) /
      2;
    solarPlexis.x = pelvis.x;
    solarPlexis.y =
      (newResults.poseLandmarks[abdomenLandmarks.RIGHT_SHOULDER].y +
        newResults.poseLandmarks[abdomenLandmarks.RIGHT_HIP].y) *
      0.6;
    newResults.poseLandmarks[POSE_LANDMARKS.PELVIS] = pelvis;
    newResults.poseLandmarks[POSE_LANDMARKS.SOLAR_PLEXIS] = solarPlexis;
  }
  return newResults;
};

/**
 * @param {number} percentage
 * @returns {string} hexColor
 * @description
 * returns a color based on the percentage similarity between the player
 * pose and model pose
 */
const percentToColor = (percentage) => {
  var r,
    g,
    b = 0;
  if (percentage &lt; 50) {
    r = 255;
    g = Math.round(5.1 * percentage);
  } else {
    g = 255;
    r = Math.round(510 - 5.1 * percentage);
  }
  var h = r * 0x10000 + g * 0x100 + b * 0x1;
  return "#" + ("000000" + h.toString(16)).slice(-6);
};

/**
 * @param {Object} config Configuration object containing:
 * - a segment key defining which body segment to look up in the SEGMENT_ANGLE_LANDMARKS object
 * - a data key defining which set of pose data to use when converting the landmark indices to coordinates
 * @param {Object} data Data object with raw landmark data to subset
 * - should have keys corresponding to values passed in the config object
 * @param {Object} container layout object defining the container values
 * - should have width and height keys with values for the container's width and height
 * @returns {Array} Array containing landmark coordinates for the segment
 */
const matchSegmentToLandmarks = (config, poseData, container) => {
  return objMap(
    SEGMENT_ANGLE_LANDMARKS[config.segment],
    landmarkToCoordinates(
      poseData[config.data],
      container.width,
      container.height
    )
  );
};

/**
 * @param {Object} playerBodySegment an object containing three landmark objects, with each landmark having an x,y coordinate
 * @param {Object} modelBodySegment an object containing three landmark objects, with each landmark having an x,y coordinate
 * @returns {number} percentage
 * @description
 * returns a percentage of similarity between the player body segment
 * and the model body segment
 * */
const segmentSimilarity = (playerBodySegment, modelBodySegment) => {
  const [playerFirst, playerSecond, playerThird] =
    Object.keys(playerBodySegment);
  const [modelFirst, modelSecond, modelThird] = Object.keys(modelBodySegment);
  return angleDifference(
    getAngle(
      playerBodySegment[playerFirst],
      playerBodySegment[playerSecond],
      playerBodySegment[playerThird]
    ),
    getAngle(
      modelBodySegment[modelFirst],
      modelBodySegment[modelSecond],
      modelBodySegment[modelThird]
    )
  );
};

/** @internal
 * @param {Object} firstPoint
 * @param {Object} secondPoint
 * @param {Object} thirdPoint
 * @returns {number} angle in radians
 */
const getAngle = (firstPoint, midPoint, lastPoint) => {
  let radians =
    Math.atan2(lastPoint.y - midPoint.y, lastPoint.x - midPoint.x) -
    Math.atan2(firstPoint.y - midPoint.y, firstPoint.x - midPoint.x);
  return radians;
};

/** @internal
 * @param {number} currentAngle
 * @param {number} desiredAngle
 * @returns {number}
 * angles are in radians
 * return value should be in range (0,100)
 * calculations for 0 to π/2 are calculated using the following formula on Wolfram Alpha:
 * exponential fit {0,0},{π*0.25,10},{π*0.45,50}, {π*0.5,100}
 * calculations for π/2 to π are calculated using the following formula on Wolfram Alpha:
 * exponential fit {π*0.5,100},{π*0.55,50}, {π*0.75,10}, {π,0}
 * */
const angleDifference = (currentAngle, desiredAngle) => {
  let translation = Math.PI * 0.5 - desiredAngle;
  let angle = currentAngle + translation;
  if (angle &lt;= Math.PI * 0.5 &amp;&amp; angle >= 0) {
    return 0.167249 * Math.exp(angle * 4.06397);
    // 0.167249 e^(4.06397 x)
  } else if (angle > Math.PI * 0.5 &amp;&amp; angle &lt;= Math.PI) {
    // 9.488988743673417*^7/E^(8.76242 x)
    // 58634. e^(-4.06397 x)
    return 58634 * Math.exp(angle * -4.06397);
  } else {
    return 0;
  }
};

export {
  preprocessPoseData,
  enrichLandmarks,
  segmentSimilarity,
  percentToColor,
  landmarkToCoordinates,
  matchSegmentToLandmarks,
  objMap,
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Character.html">Character</a></li><li><a href="Face.html">Face</a></li></ul><h3>Global</h3><ul><li><a href="global.html#angleDifference">angleDifference</a></li><li><a href="global.html#enrichLandmarks">enrichLandmarks</a></li><li><a href="global.html#generateRowAndColumnFunctions">generateRowAndColumnFunctions</a></li><li><a href="global.html#getAngle">getAngle</a></li><li><a href="global.html#landmarkCoordinates">landmarkCoordinates</a></li><li><a href="global.html#matchSegmentToLandmarks">matchSegmentToLandmarks</a></li><li><a href="global.html#percentToColor">percentToColor</a></li><li><a href="global.html#segmentSimilarity">segmentSimilarity</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Mon Dec 13 2021 17:44:46 GMT-0600 (Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
